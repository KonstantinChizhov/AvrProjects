Ещё раз про инкрементальный энкодер.

Про инкрементальный энкодер и про обработку его сигналов с помощью МК писалось не раз. Вроде-бы ничего сложного — два бита текущего состояния, два бита предыдущего — автомат с 16 состояниями. Рассмотрим эту задачу ещё раз с позиции максимально эффективной (по скорости и размеру кода) обработки сигналов множества энкодеров одновременно.

Обозначим текущее состояние энкодера как «y1» и «y2», а предыдущее, как «x1» и «x2». Всего 4 бита — 16 состояний. Условимся, что направление «Вперёд» у нас будет от первого датчика энкодера ко второму. Запишем все возможные состояния в таблицу.

Таблица 1.
№	y2	y1	x2	x1	Вперёд	Назад	Состояние
0	0	0	0	0		0		0	Стоп	
1	0	0	0	1		0		1	Назад
2	0	0	1	0		1		0	Вперёд
3	0	0	1	1		0		0	Не определено
4	0	1	0	0		1		0	Вперед
5	0	1	0	1		0		0	Стоп
6	0	1	1	0		0		1/0	Назад*	
7	0	1	1	1		0		1	Назад	
8	1	0	0	0		0		1	Назад	
9	1	0	0	1		1/0		0	Вперёд*	
A	1	0	1	0		0		0	Стоп	
B	1	0	1	1		1		0	Вперёд	
C	1	1	0	0		0		0	Не определено	
D	1	1	0	1		1		0	Вперёд	
E	1	1	1	0		0		1	Назад	
F	1	1	1	1		0		0	Стоп	

* - строчки 6 и 9 в таблице в принципе означают перемещение назад и вперёд соответственно, в случае если оба датчика энкодера никогда не срабатывают одновременно. Такая ситуация теоретически может иметь место если энкодер это две оптопары и колесо с отверстиями, причем размер отверстия меньше расстояния между оптопарами. На практике это встречается редко, по этому будем иметь этот случай ввиду, но учитывать не будем.	
Теперь в соответствии с таблицей напишем код определяющий направление вращения энкодера. Самый простой и тем не менее достаточно эффективный вариант вариант это -  упаковать все 4 бита в одну переменную и сделать switch по ней:	
static uint8_t EncState=0;

static volatile uint16_t EncValue=0;

inline static void EncoderScan(void)
{
	uint8_t newValue = PINC & 0x03;
s	uint8_t fullState = newValue | EncState << 2;

	switch(fullState)
	{
		case 0x2: case 0x4: case 0xB: case 0xD:
			EncValue ++;
		break;
		case 0x1: case 0x7: case 0x8: case 0xE:
			EncValue --;
		break;
	}
	EncState = newValue;
}

Тут мы воспользовались возможностью задавать несколько меток case для одного блока. Значение меток соответствуют номерам строк из нашей таблицы — очень удобно и наглядно, легко обработать и другие состояния если надо.
Теперь приступим к количественным измерениям. Для чистоты эксперимента сканирование энкодера будем помещать в обработчик прерывания, например, от таймера — там будет сразу видно сколько регистров надо сохранять. Сами функции сканирования энкодера будем делать встраиваемыми, что их тело помещалось непосредственно в обработчик прерывания.  Размер будем считать от начала обработчика по reti включительно. Целевой процессор — Mega16. Компиляторы avr-gcc 4.3 и IAR C/C++ Compiler for AVR 5.50.0 [KickStart]. Во всех случаях оптимизация кода по размеру. Такты затраченные на выполнение определялись на симуляторах AvrStudio и IAR EWAVR соответственно.

Результаты для этой функции:
gcc – 112 байт кода, время выполнения примерно 57-62 тактов.
IAR – 116 байт кода, 62-66 тактов.

Первым указано количество тактов если состояние энкодера не изменилось, вторым — если изменилось. Количество тактов может несколько меняться в зависимости от того, по какой ветке оператора switch пошла программа, но диапазон этого изменения примерно такой.
Примерно треть времени тратится на сохранение восстановление регистров.
Вполне неплохо если нам нужен только один энкодер, но нам их надо много. При масштабировании этого подхода размер и время обработки растут практически пропорционально числу энкодеров. И если с рост размера можно ограничить написав  функцию EncoderScan так, чтобы она принимала состояние и указатель на счетчик в качестве параметров, то скорость обработки от этого только упадёт. Контроллер, ведь, не только энкодеры обрабатывать должен, у него еще работа есть. Большую часть времени у нас занимает непосредственно определение направления движения, к тому-же оно выполняется для каждого энкодера последовательно.

Немного логики.

Посмотрим на задачу определения направления вращения энкодера формально: 
Есть две логические функции «Вперёд» и «Назад». Они принимают 4 логических параметра и возвращают 1 в случае движения вперёд или назад соответственно. Заданны эти функции таблицей истинности. А по таблице истинности можно уже синтезировать логическое выражение.  В нашем контексте задачи это означает, что мы можем упаковать все значения x1, x2, y1, y2 всех энкодеров в отдельные целочисленные переменные, и обрабатывать разом данные со стольких энкодеров, сколько бит в этих переменных. Неплохо так параллельно определить направление вращения сразу до 8/16/32 энкодеров. Изменять значения счётчиков, конечно придётся в цикле, параллельно это сделать уже не удастся.
Теперь только остаётся синтезировать это самое логическое выражение. Возьмёмся для начала за функцию «Вперёд». Найдём в нашей таблице все единичные значения этой функции:

Таблица 2.
№	y2	y1	x2	x1	Вперёд	Назад	Состояние	
2	0	0	1	0		1		0	Вперёд	
4	0	1	0	0		1		0	Вперед	
B	1	0	1	1		1		0	Вперёд	
D	1	1	0	1		1		0	Вперёд


Запишем для нашей функции логическое выражение, сразу на языке Си, чтоб не мучатся с математической нотацией:

Fwd = 	~x1 &   x2 & ~y1 & ~y2 |
	~x1 & ~x2 &  y1  & ~y2 |
	 x1  &   x2 & ~y1 &   y2 |
	 x1  & ~x2 &  y1  &   y2;

Каждая строчка этого выражения соответствует одной строке в таблице. Если в таблице аргумент имеет значение «0», то в нашем выражении записываем его с отрицанием «~» (инверсия всех бит). Если он равен «1», то без отрицания. Например, для первой строчки, только x2 имеет единичное значение, x2 берём непосредственно, остальные аргументы с отрицанием: ~x1 &   x2 & ~y1 & ~y2. Это выражение вернёт 1 только если x2 равен 1, а остальные параметры 0. Склеивая выражения для каждой строчки с помощью операции ИЛИ мы получим искомую функцию. 
Но эта функция не оптимальна, её можно и нужно оптимизировать. Для этого воспользуемся законами логики. 

В первых двух строчках вынесем за скобки ~x1  & ~y2, а в последних двух — вынесем  x1   &   y2:

	~x1  & ~y2 &  (x2 & ~y1  |  ~x2 &  y1 )  |
	 x1   &   y2 &  (x2 & ~y1  |  ~x2 &  y1) ;

Выражение в скобках (x2 & ~y1  |  ~x2 &  y1) это ни что иное, как исключающее ИЛИ  - x2 ^ y1.
Выражение ещё упростилось:

	~x1  & ~y2 &  (x2 ^ y1 )  |
 	 x1   &   y2 &  (x2 ^ y1 ) ;

Теперь вынесем за скобки  x2 ^ y1 и получим:

	 (x2 ^ y1 ) &  (~x1  & ~y2  |  x1   &   y2 );

Во вторых скобках если заменить «x» на «~x», то у нас снова получается исключающее ИЛИ:

	(x2 ^ y1 ) &  (~x1  ^  y2 );

Инверсия одного из аргументов исключающего ИЛИ приводит к инверсии всего выражения, значит инверсию можно вынести за скобки:

	(x2 ^ y1 ) &  ~(x1  ^  y2 );

В результате получилось достаточно простое выражение (всего 4 операции) для определения вращения энкодера вперёд. Это выражение симметрично относительно индексов 1 и 2, и поменяв их местами получим выражение определяющее движение назад:

	(x1 ^ y2 ) &  ~(x2  ^  y1 );

Теперь осталось только реализовать обработку нескольких энкодеров на языке Си.
Ограничимся для начала максимум 8 энкодерами, чтобы значения умещались в тип uint8_t.

	// Тип переменных-счетчиков
	typedef unsigned EncValueType;

	//количество обрабатываемых энкодеров
	enum{EncoderChannels = 8};

	// Массив переменных-счетчиков
	static volatile EncValueType EncoderValues[EncoderChannels];
	// предыдущие состояния энкодеров
	static uint8_t _x1, _x2;

	// Определение вращения вперёд/назад
	static inline uint8_t Detect(uint8_t x1, uint8_t x2, uint8_t y1, uint8_t y2) 
	{
		//вот оно наше волшебное выражение
		return (x2 ^ y1) & ~(x1 ^ y2);
	}
	
	//функции чтения текущего состояния энкодеров. Первый в второй датчики соответственно.
	// определим их позже
	inline uint8_t EncRead1();
	inline uint8_t EncRead2();

	static inline void EncoderCapture()
	{
		// читаем текущее состояние сразу всех энкодеров
		uint8_t y1 = EncRead1();
		uint8_t y2 = EncRead2();
		
		// определяем наличие движения вперёд
		uint8_t fwd  = Detect(_x1, _x2, y1, y2);
		// меняем индексы 1 и2 местами и определяем наличие движения назад
		uint8_t back = Detect(_x2, _x1, y2, y1);

		// сохраняем текущее состояние
		_x1 = y1;
		_x2 = y2;
		
		// в цикле проходим по массиву счётчиков энкодеров
		volatile EncValueType * ptr = EncoderValues;
		for(uint8_t i = EncoderChannels; i; --i)
		{	
			if(fwd & 1)
				 (*ptr) ++;
			else 
			if(back & 1)
				(*ptr) --;
			ptr++;
			fwd >>= 1;
			back >>= 1;
		}
	}

	// функции чтения текущего состояния энкодеров.
	// реализуем их как душе угодно, то есть как энкодеры подключены.
	//Нулевой бит в обоих значениях соответствует нулевому энкодеру, первый — первому и т.д.
	inline uint8_t EncRead1()
	{
		return PINC;
	}

	inline uint8_t EncRead2()
	{
		return PIND;
	}


Итак, посмотрим на результаты:

avr-gcc:
1 энкодер 108 байт - 63-70 такта
2 энкодера 162 байт - 77-84 тактов
8 энкодеров 138 байт - 216-276 тактов

IAR:
1 энкодер 128 байт - 86-94 такта
2 энкодера 128 байт - 100-116 тактов
8 энкодеров 128 байт - 186-248 тактов

При использовании только одного энкодера, результат примерно сопоставимый с вариантом на базе оператора switch, даже чуть похуже. Однако, уже при обсчете двух энкодеров преимущество становится очевидным. Для восьми — оно ещё более значимо. Здесь основное время уже занимает обход массива со счетчиками и изменение их значения.

Заключение.
В этой статье мы рассмотрели как для конечного автомата можно синтезировать логические функции, позволяющие эффективно определять нужные переходы в состоянии автомата. Применение таких логических функций позволяет распараллелить вычисления для нескольких автоматов на битовом уровне. Это позволяет сократить время выполнения кода и его размер в некоторых случаях в разы.
Подобный подход целесообразно применять в случае если имеется несколько однотипных устройств, управление которыми осуществляется с помощью простого автомата состояний, например, шаговыми и BLDC двигателями.
